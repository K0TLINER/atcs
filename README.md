# 1. 프로젝트 개요

이 프로젝트는 넥슨 기술 블로그에 소개된 ATCS (Active Traffic Control System)를 직접 구현한 것입니다. 기술 블로그의 내용을 최대한 충실히 반영했으며, 사소한 내용을 신경쓰기보단 프로젝트의 중요한 부분위주로 구현했습니다. 프로젝트는 다음 두 가지 서비스로 구성됩니다:

### 1. **nxcommand**

- **역할**: 사용자의 요청을 받아서 해당 서버에 전달하는 역할을 합니다.
- **기능**:
    - 서버에 트래픽이 몰리는 경우 과부하를 방지하기 위해 ATCS 서비스를 통해 서버 호출 가능 여부를 확인합니다.
    - 서버가 호출 가능한 상태일 때만 요청을 처리합니다.

### 2. **atcs**

- **역할**: nxcommand로부터 전달받은 요청을 처리하기 전에, 서버가 호출 가능한 상태인지 확인한 후 그 결과를 다시 nxcommand에 전달합니다.
- **기능**:
    - 서버가 호출 불가능한 상태일 경우, 요청을 대기열에 보류합니다.
    - nxcommand가 이전 요청을 성공적으로 처리했을 때, 보류된 요청을 재확인하여 처리합니다.
    - 이 과정이 반복되어 시스템의 안정성을 유지합니다.

이 프로젝트는 실제 환경에서 발생할 수 있는 서버 과부하 문제를 해결하기 위한 기술적 접근 방식을 실습하고 이해하는 데 중점을 두고 있습니다.

# 2. 주요 기능

### 1. **REST 요청 처리**

- **설명**: Downstream에서 들어오는 요청을 REST API를 통해 처리합니다. HTTP 헤더에 포함된 정보를 기반으로, 어떤 게임 서버에 어떤 요청을 보낼지 결정합니다.

### 2. **대기열 등록 및 인출**

- **설명**: 요청된 정보를 대기열(Queue)에 등록하여 요청의 순서를 보장합니다. 서버가 요청을 처리할 수 없는 상황에서는 대기 중인 요청을 보류하고, 처리 가능한 상태가 되면 대기열에서 요청을 인출하여 처리합니다.

### 3. **Pub/Sub 시스템**

- **설명**: 서로 다른 서비스 간의 통신을 위해 Pub/Sub 시스템을 사용하여 이벤트를 주고받으며 동작을 조율합니다.

### 4. **캐싱 시스템**

- **설명**: 각 서버의 트래픽 정보를 캐싱 시스템에 저장하여 효율적으로 관리합니다. 캐싱을 통해 서버 부하를 줄이고 응답 속도를 개선합니다.

# 3. 기술 스택

### **프로그래밍 언어 및 프레임워크**

- **Java**: 백엔드 로직 구현을 위한 주 프로그래밍 언어.
- **Spring Boot**: REST API 개발과 의존성 관리, 애플리케이션 설정을 간소화하는 프레임워크.

### **데이터 관리**

- **Redis**: 서버 트래픽을 효율적으로 관리하기 위한 캐싱 시스템과 대기열 관리에 사용.

### **메시징 시스템**

- **Redis Pub/Sub**: 서로 다른 서비스 간의 비동기 이벤트 통신을 위해 사용되는 메시징 시스템.

# 4. 프로젝트 구조

이 프로젝트에서 핵심이라고 생각되는 부분만 작성했습니다. nxcommand와 atcs 둘 서비스에서 중복되는 패키지 이름이 많기때문에 nxcommand 패지키만 작성했습니다.

- **com/example/nxcommand/channel**: Pub/Sub 시스템에서 채널에 사용되는 객체를 포함하고 있다.
- **com/example/nxcommand/data/queue**: 대기열 시스템을 사용하기 위한 객체를 포함하고 있다.
- **com/example/nxcommand/adpater**: 외부 애플리케이션을 사용하기 위한 어댑터 객체를 포함하고 있다.
- **com/example/nxcommand/service**: 핵심 비지니스 로직을 담고 있고, 해당 비지니스 로직을 실행하기 전 AOP를 적용할 aspect 객체도 포함하고 있다.
- **com/example/nxcommand/config**: 애플리케이션 설정 클래스를 포함하고 있다.
- **com/example/nxcommand/data**: 애플리케이션과 외부에서 사용할 데이터 객체를 포함하고 있으며 커스텀 직렬화 클래스도 포함하고 있다.
# 5. 프로젝트 핵심

게임 서버(`maple`, `baram`, `kart` 등), 타겟 정보(`coupon` 등), 서버 정보(`qa-01`, `prod`)를 포함하는 식별자를 `enum`으로 관리하며, 이를 하나의 객체로 모아 서버 간 공유합니다. 예를 들어, `maple:coupon:qa-01`과 같은 식별자를 통해 게임 정보를 downstream에 전달합니다.

ATCS 서비스로 요청을 전달하기 위해 Redis를 활용한 대기열 및 Pub/Sub 시스템을 구현했습니다. `RedisConfig` 설정 클래스에서 다양한 키 값을 처리할 수 있도록 여러 개의 `RedisTemplate`을 Bean으로 등록하고, `@Qualifier` 어노테이션을 통해 필요한 Bean을 지정하여 사용합니다.

- **대기열 관리**: 게임 서버와 관련된 요청을 관리하기 위해 두 개의 Adapter 클래스를 생성하여 대기열의 의존도를 낮췄습니다.
- **이벤트 리스너**: 일관성을 유지하기 위해 추상 이벤트 리스너 클래스를 생성하고, 추상 팩터리 패턴을 이용하여 각 채널 및 이벤트 객체에 맞게 구현했습니다.

요청을 ATCS 서비스에 넘기기 전에, 요청 타임아웃 시간과 캐시에 저장된 요청 처리 대기 시간을 비교하여 더 오래 걸릴 경우 대기열에 요청을 넣지 않습니다. 대신, `MyException`을 확장한 `ManyRequestException` 예외를 발생시키고, `ControllerAdvice` 클래스를 통해 `429 Too Many Requests` 상태 코드를 반환합니다.

ATCS 서비스는 다음 절차를 진행하기 전에 AOP를 이용하여 트래픽을 확인합니다. 트래픽 상황은 캐시에서 확인이 가능하기에 캐시 조회를 위한 `CacheAdapter` 클래스를 사용하며, `LuaScript`를 통해 동시성 문제를 해결했습니다. 증가와 감소 작업을 각각 다른 스크립트 파일로 나누고, 필요에 따라 다른 Bean 이름을 사용하여 적절하게 주입했습니다.

이러한 설정을 통해서 넥슨 공식 기술 블로그에서 소개한 트래픽을 조절하기 위한 절차를 최대한 비슷하게 구현해보았습니다. 이벤트의 흐름을 추적하고 검증하기 위해 `SLF4J`를 통해 로그를 작성했습니다.

==로그 캡쳐본 업로드 예정==

# 6. 설치 및 사용 예시

==글 추가 예정==

# 7. 참고 자료

[nexon 인텔리전스 랩스 ATCS 소개](https://www.intelligencelabs.tech/2a35b8f1-038a-4fb0-83af-3f81eca61162)

[gmarket 기술블로그 API Limiter 소개](https://dev.gmarket.com/69)

[참고한 스프링 부트 서적](https://product.kyobobook.co.kr/detail/S000200221921)

[참고한 디자인 패턴 서적](https://product.kyobobook.co.kr/detail/S000001810483)

# 8. 나의 생각

### 1. SDK

원래 이 프로젝트는 넥슨 기술 블로그를 참고하여 SDK를 개발하고 이를 `nxcommand`에 적용하는 것이 목표였습니다. 그러나 실제 구현 과정에서 두 개의 서비스(`nxcommand`와 `atcs`)에서 중복되는 코드가 상당히 많아지는 문제를 겪었습니다. SDK를 개발하여 각 서비스에서 공통으로 사용될 수 있도록 하려고 했지만, 범용적인 SDK를 만드는 것이 생각보다 쉽지 않았습니다. 이는 디자인 패턴에 대한 깊은 지식이 필요했고, 여러 서비스에서 범용적으로 사용될 수 있는 툴킷을 개발하는 과정에서 많은 어려움을 겪었습니다.

사실, 저는 아직 범용적인 프로젝트를 직접 경험해본 적이 없으며, 이론적인 공부에 머물러 있었습니다. 그래서 더 완벽한 프로젝트를 만들기 위해 코드를 지우고 다시 작성하는 과정을 반복했습니다. 그러나 이 과정은 끝이 보이지 않았습니다. 어떻게 설계해도 문제가 있어 보였고, 적당한 기준을 세우는 것이 매우 어려웠습니다.

결국, 이번 프로젝트의 핵심 목표가 트래픽 제한 장치를 구현하는 것이었기 때문에, SDK 개발을 우선시하지 않기로 했습니다. 대신, 언젠가 여러 개발자들이 사용할 수 있는 범용적인 패키지를 구성하기 위해 디자인 패턴과 클린 코드에 대한 깊은 이해를 얻고, 잘 작성된 프로젝트들을 통해 저의 개발 역량을 한 단계 높이고자 합니다.

### 2. Test

어떤 로직이 제대로 작동하는지 확인하기 위해서는 테스트가 필수적입니다. 하지만 이 프로젝트는 캐시, 대기열, 이벤트 구독과 같은 여러 애플리케이션이 상호작용하는 복잡한 구조를 가지고 있어, 테스트 케이스를 작성하는 것이 쉽지 않았습니다. 실무에서는 이러한 다양한 서버 환경에서 어떻게 테스트를 관리하고 유지하는지 아직 잘 알지 못했습니다.

Profile을 통해 개발 환경을 구성하고 실무를 흉내내며 테스트하려고 했지만, 실제로 실력을 키우는 데는 한계가 있었습니다. 완벽한 기준을 찾는 것이 어렵다 보니, 테스트가 성공하더라도 그것이 모든 상황을 대변할 수 있는지 확신하기 어려웠습니다.

결국, 이번 프로젝트에서는 자동화된 테스트 케이스를 작성하지 못하고, 수동으로 테스트를 진행했습니다. 즉, 테스트를 수행하긴 했지만, 자동화된 테스트 코드가 없습니다. 앞으로 자신 있는 테스트를 할 수 있도록 여러 기술 블로그나 Medium 포스팅 등을 통해 학습하고, 테스트 작성에 대한 경험을 쌓아가려고 합니다.

### 3. Transaction

Lua 스크립트를 통해 Redis에 접근하여 데이터를 원자적으로 수정할 수 있지만, 이번 프로젝트에서는 대기열에 등록하고 이벤트를 발행하는 작업을 원자적으로 수행하는 것이 어려웠습니다. 이러한 동작을 원자적으로 보장하기 위해 Redis와 Spring Boot에 대해 더 깊이 공부해야 할 필요성을 느꼈습니다. 이 부분은 앞으로 해결해야 할 숙제로 남겨두었습니다.

### 4. AWS

현재 AWS 무료 플랜이 만료되어 기술 블로그에서 소개된 `ElastiCache`와 `ETag` 기능을 사용할 수 없게 되었습니다. 하지만 다른 클라우드 플랫폼을 활용하여 유사한 기능을 구현할 계획입니다.
